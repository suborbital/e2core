package publisher

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	bclient "github.com/deislabs/go-bindle/client"
	"github.com/deislabs/go-bindle/keyring"
	"github.com/deislabs/go-bindle/types"
	"github.com/pelletier/go-toml"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v2"

	"github.com/suborbital/e2core/e2/cli/util"
	"github.com/suborbital/e2core/e2/project"
)

const (
	BindlePublishJobType = "bindle"
	suboAuthor           = "Subo <subo@suborbital.dev>"
)

type BindlePublishJob struct{}

type parcelWrapper struct {
	parcel types.Parcel
	data   []byte
}

// NewBindlePublishJob returns a new PublishJob for Bindle.
func NewBindlePublishJob() PublishJob {
	b := &BindlePublishJob{}

	return b
}

// Type returns the publish job's type.
func (b *BindlePublishJob) Type() string {
	return BindlePublishJobType
}

// Publish publishes the application.
func (b *BindlePublishJob) Publish(log util.FriendlyLogger, ctx *project.Context) error {
	if ctx.TenantConfig == nil {
		return errors.New("ðŸš« cannot push without tenant.json file")
	}

	log.LogStart(fmt.Sprintf("pushing %s@%d", ctx.TenantConfig.Identifier, ctx.TenantConfig.TenantVersion))

	invoice := &types.Invoice{
		BindleVersion: "1.0.0",
		Bindle: types.BindleSpec{
			Name:    ctx.TenantConfig.Identifier,
			Version: fmt.Sprintf("%d", ctx.TenantConfig.TenantVersion),
			Authors: []string{
				suboAuthor,
			},
		},
		Parcel: []types.Parcel{},
	}

	parcelsBySHA := map[string]parcelWrapper{}

	// add the Directive as a parcel.
	configBytes, err := yaml.Marshal(ctx.TenantConfig)
	if err != nil {
		return errors.Wrap(err, "failed to Marshal Directive")
	}

	tenantParcel := parcelForData("tenant.yaml", "application/yaml", configBytes)

	invoice.Parcel = append(invoice.Parcel, tenantParcel)

	parcelsBySHA[tenantParcel.Label.SHA256] = parcelWrapper{
		parcel: tenantParcel,
		data:   configBytes,
	}

	// add each module as a parcel.
	for _, mod := range ctx.Modules {
		files, err := ioutil.ReadDir(mod.Fullpath)
		if err != nil {
			return errors.Wrapf(err, "failed to ReadDir for %s", mod.Fullpath)
		}

		for _, file := range files {
			if !strings.HasSuffix(file.Name(), ".wasm") {
				continue
			}

			fullPath := filepath.Join(mod.Fullpath, file.Name())

			fileBytes, err := os.ReadFile(fullPath)
			if err != nil {
				return errors.Wrapf(err, "failed to Open %s", fullPath)
			}

			parcel := parcelForData(file.Name(), "application/wasm", fileBytes)

			invoice.Parcel = append(invoice.Parcel, parcel)

			parcelsBySHA[parcel.Label.SHA256] = parcelWrapper{
				parcel: parcel,
				data:   fileBytes,
			}
		}
	}

	sigKey, privKey, err := createOrReadKeypair(suboAuthor)
	if err != nil {
		return errors.Wrap(err, "failed to createOrReadKeypair")
	}

	if err := invoice.GenerateSignature(suboAuthor, types.RoleCreator, sigKey, privKey); err != nil {
		return errors.Wrap(err, "failed to GenerateCreatorSignaure")
	}

	client, err := bclient.New("http://127.0.0.1:8080/v1", nil)
	if err != nil {
		return errors.Wrap(err, "failed to client.New")
	}

	invResp, err := client.CreateInvoice(*invoice)
	if err != nil {
		return errors.Wrap(err, "failed to CreateInvoice")
	}

	for _, p := range invResp.Missing {
		wrapper := parcelsBySHA[p.SHA256]

		if err := client.CreateParcel(invoice.Name(), p.SHA256, wrapper.data); err != nil {
			return errors.Wrapf(err, "failed to CreateParcel for %s", wrapper.parcel.Label.Name)
		}
	}

	invoiceBytes, err := toml.Marshal(invoice)
	if err != nil {
		return errors.Wrap(err, "failed to Marshal invoice")
	}

	invoiceBytes = append([]byte("# Autogenerated Bindle Invoice, do not edit\n\n"), invoiceBytes...)

	if err := os.WriteFile(filepath.Join(ctx.Cwd, "Invoice.toml"), invoiceBytes, util.PermFile); err != nil {
		return errors.Wrap(err, "failed to WriteFile for Invoice.toml")
	}

	util.LogDone("pushed")

	return nil
}

func parcelForData(name, mediaType string, data []byte) types.Parcel {
	sha := sha256.New()
	sha.Write(data)

	fileSHA := hex.EncodeToString(sha.Sum(nil))

	label := types.Label{
		SHA256:    fileSHA,
		MediaType: mediaType,
		Name:      name,
		Size:      uint64(len(data)),
	}

	parcel := types.Parcel{
		Label: label,
	}

	return parcel
}

func createOrReadKeypair(author string) (*types.SignatureKey, []byte, error) {
	var sigKey *types.SignatureKey
	var privKey []byte

	kr, err := keyring.LocalKeyring()
	if err != nil {
		sigKey, privKey, err = keyring.GenerateSignatureKey(author, "creator")
		if err != nil {
			return nil, nil, errors.Wrap(err, "failed to GenerateSignatureKey")
		}

		if err := keyring.AddLocalKey(sigKey); err != nil {
			return nil, nil, errors.Wrap(err, "failed to AddLocalKey")
		}

		if err := keyring.WritePrivKey(privKey, privKeyFilepath()); err != nil {
			return nil, nil, errors.Wrap(err, "failed to WritePrivateKey")
		}

		return sigKey, privKey, nil
	}

	// find the SignatureKey in the local Keyring.
	for i, k := range kr.Key {
		if k.Label == author {
			sigKey = &kr.Key[i]
			break
		}
	}

	// read the privkey from the '.ssh' location.
	privKey, err = keyring.ReadPrivKey(privKeyFilepath())
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to ReadPrivKey")
	}

	return sigKey, privKey, nil
}

func privKeyFilepath() string {
	home := "$HOME"

	if usrHome, err := os.UserHomeDir(); err == nil {
		home = usrHome
	}

	return filepath.Join(home, ".ssh", "bindle_ed25519")
}
