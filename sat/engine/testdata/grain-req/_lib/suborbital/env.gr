/* This file was generated by witx-bindgen. Do not edit. */

import DataStructures from "runtime/dataStructures"
import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import WasmF32 from "runtime/unsafe/wasmf32"
import WasmF64 from "runtime/unsafe/wasmf64"
import Memory from "runtime/unsafe/memory"
import Int32 from "int32"
import Int64 from "int64"
import Char from "char"
import List from "list"

export enum LogLevel {
  LogLevelNull,
  LogLevelError,
  LogLevelWarn,
  LogLevelInfo,
  LogLevelDebug,
},
export enum HttpMethod {
  HttpMethodGet,
  HttpMethodHead,
  HttpMethodOptions,
  HttpMethodPost,
  HttpMethodPut,
  HttpMethodPatch,
  HttpMethodDelete,
},
export enum FieldType {
  FieldTypeMeta,
  FieldTypeBody,
  FieldTypeHeader,
  FieldTypeParams,
  FieldTypeState,
}

import foreign wasm return_result: (WasmI32, WasmI32, WasmI32) -> Void as witx_bindgen_returnResult from "env"
@disableGC
export let rec returnResult: (Bytes, Int32) -> Void = (res, ident) => {
  let vec0 = res
  let ptr0 = WasmI32.add(WasmI32.fromGrain(vec0), 8n)
  let len0 = WasmI32.load(WasmI32.fromGrain(vec0), 4n)
  let int32_1 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  witx_bindgen_returnResult(ptr0, len0, int32_1)
  Memory.decRef(WasmI32.fromGrain(returnResult))
  Memory.decRef(WasmI32.fromGrain(res))
  Memory.decRef(WasmI32.fromGrain(ident))
  void
}

import foreign wasm return_error: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void as witx_bindgen_returnError from "env"
@disableGC
export let rec returnError: (Int32, String, Int32) -> Void = (code, res, ident) => {
  let int32_0 = WasmI32.load(WasmI32.fromGrain(code), 8n)
  let vec1 = res
  let ptr1 = WasmI32.add(WasmI32.fromGrain(vec1), 8n)
  let len1 = WasmI32.load(WasmI32.fromGrain(vec1), 4n)
  let int32_2 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  witx_bindgen_returnError(int32_0, ptr1, len1, int32_2)
  Memory.decRef(WasmI32.fromGrain(returnError))
  Memory.decRef(WasmI32.fromGrain(code))
  Memory.decRef(WasmI32.fromGrain(res))
  Memory.decRef(WasmI32.fromGrain(ident))
  void
}

import foreign wasm log_msg: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void as witx_bindgen_logMsg from "env"
@disableGC
export let rec logMsg: (String, LogLevel, Int32) -> Void = (msg, level, ident) => {
  let vec0 = msg
  let ptr0 = WasmI32.add(WasmI32.fromGrain(vec0), 8n)
  let len0 = WasmI32.load(WasmI32.fromGrain(vec0), 4n)
  let mut result1_0 = 0n
  match (level) {
    LogLevelNull => {
      result1_0 = 0n
    },
    LogLevelError => {
      result1_0 = 1n
    },
    LogLevelWarn => {
      result1_0 = 2n
    },
    LogLevelInfo => {
      result1_0 = 3n
    },
    LogLevelDebug => {
      result1_0 = 4n
    },
  }
  let int32_2 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  witx_bindgen_logMsg(ptr0, len0, result1_0, int32_2)
  Memory.decRef(WasmI32.fromGrain(logMsg))
  Memory.decRef(WasmI32.fromGrain(msg))
  Memory.decRef(WasmI32.fromGrain(level))
  Memory.decRef(WasmI32.fromGrain(ident))
  void
}

import foreign wasm fetch_url: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 as witx_bindgen_fetchUrl from "env"
@disableGC
export let rec fetchUrl: (HttpMethod, String, Bytes, Int32) -> Int32 = (method, url, body, ident) => {
  let mut result0_0 = 0n
  match (method) {
    HttpMethodGet => {
      result0_0 = 0n
    },
    HttpMethodHead => {
      result0_0 = 1n
    },
    HttpMethodOptions => {
      result0_0 = 2n
    },
    HttpMethodPost => {
      result0_0 = 3n
    },
    HttpMethodPut => {
      result0_0 = 4n
    },
    HttpMethodPatch => {
      result0_0 = 5n
    },
    HttpMethodDelete => {
      result0_0 = 6n
    },
  }
  let vec1 = url
  let ptr1 = WasmI32.add(WasmI32.fromGrain(vec1), 8n)
  let len1 = WasmI32.load(WasmI32.fromGrain(vec1), 4n)
  let vec2 = body
  let ptr2 = WasmI32.add(WasmI32.fromGrain(vec2), 8n)
  let len2 = WasmI32.load(WasmI32.fromGrain(vec2), 4n)
  let int32_3 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  let ret = witx_bindgen_fetchUrl(result0_0, ptr1, len1, ptr2, len2, int32_3)
  let int32_4 = WasmI32.toGrain(DataStructures.newInt32(ret)): Int32
  Memory.decRef(WasmI32.fromGrain(fetchUrl))
  Memory.decRef(WasmI32.fromGrain(method))
  Memory.decRef(WasmI32.fromGrain(url))
  Memory.decRef(WasmI32.fromGrain(body))
  Memory.decRef(WasmI32.fromGrain(ident))
  int32_4
}

import foreign wasm graphql_query: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 as witx_bindgen_graphqlQuery from "env"
@disableGC
export let rec graphqlQuery: (String, String, Int32) -> Int32 = (endpoint, query, ident) => {
  let vec0 = endpoint
  let ptr0 = WasmI32.add(WasmI32.fromGrain(vec0), 8n)
  let len0 = WasmI32.load(WasmI32.fromGrain(vec0), 4n)
  let vec1 = query
  let ptr1 = WasmI32.add(WasmI32.fromGrain(vec1), 8n)
  let len1 = WasmI32.load(WasmI32.fromGrain(vec1), 4n)
  let int32_2 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  let ret = witx_bindgen_graphqlQuery(ptr0, len0, ptr1, len1, int32_2)
  let int32_3 = WasmI32.toGrain(DataStructures.newInt32(ret)): Int32
  Memory.decRef(WasmI32.fromGrain(graphqlQuery))
  Memory.decRef(WasmI32.fromGrain(endpoint))
  Memory.decRef(WasmI32.fromGrain(query))
  Memory.decRef(WasmI32.fromGrain(ident))
  int32_3
}

import foreign wasm cache_set: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 as witx_bindgen_cacheSet from "env"
@disableGC
export let rec cacheSet: (String, Bytes, Int32, Int32) -> Int32 = (key, value, ttl, ident) => {
  let vec0 = key
  let ptr0 = WasmI32.add(WasmI32.fromGrain(vec0), 8n)
  let len0 = WasmI32.load(WasmI32.fromGrain(vec0), 4n)
  let vec1 = value
  let ptr1 = WasmI32.add(WasmI32.fromGrain(vec1), 8n)
  let len1 = WasmI32.load(WasmI32.fromGrain(vec1), 4n)
  let int32_2 = WasmI32.load(WasmI32.fromGrain(ttl), 8n)
  let int32_3 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  let ret = witx_bindgen_cacheSet(ptr0, len0, ptr1, len1, int32_2, int32_3)
  let int32_4 = WasmI32.toGrain(DataStructures.newInt32(ret)): Int32
  Memory.decRef(WasmI32.fromGrain(cacheSet))
  Memory.decRef(WasmI32.fromGrain(key))
  Memory.decRef(WasmI32.fromGrain(value))
  Memory.decRef(WasmI32.fromGrain(ttl))
  Memory.decRef(WasmI32.fromGrain(ident))
  int32_4
}

import foreign wasm cache_get: (WasmI32, WasmI32, WasmI32) -> WasmI32 as witx_bindgen_cacheGet from "env"
@disableGC
export let rec cacheGet: (String, Int32) -> Int32 = (key, ident) => {
  let vec0 = key
  let ptr0 = WasmI32.add(WasmI32.fromGrain(vec0), 8n)
  let len0 = WasmI32.load(WasmI32.fromGrain(vec0), 4n)
  let int32_1 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  let ret = witx_bindgen_cacheGet(ptr0, len0, int32_1)
  let int32_2 = WasmI32.toGrain(DataStructures.newInt32(ret)): Int32
  Memory.decRef(WasmI32.fromGrain(cacheGet))
  Memory.decRef(WasmI32.fromGrain(key))
  Memory.decRef(WasmI32.fromGrain(ident))
  int32_2
}

import foreign wasm request_get_field: (WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 as witx_bindgen_requestGetField from "env"
@disableGC
export let rec requestGetField: (FieldType, String, Int32) -> Int32 = (fieldType, key, ident) => {
  let mut result0_0 = 0n
  match (fieldType) {
    FieldTypeMeta => {
      result0_0 = 0n
    },
    FieldTypeBody => {
      result0_0 = 1n
    },
    FieldTypeHeader => {
      result0_0 = 2n
    },
    FieldTypeParams => {
      result0_0 = 3n
    },
    FieldTypeState => {
      result0_0 = 4n
    },
  }
  let vec1 = key
  let ptr1 = WasmI32.add(WasmI32.fromGrain(vec1), 8n)
  let len1 = WasmI32.load(WasmI32.fromGrain(vec1), 4n)
  let int32_2 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  let ret = witx_bindgen_requestGetField(result0_0, ptr1, len1, int32_2)
  let int32_3 = WasmI32.toGrain(DataStructures.newInt32(ret)): Int32
  Memory.decRef(WasmI32.fromGrain(requestGetField))
  Memory.decRef(WasmI32.fromGrain(fieldType))
  Memory.decRef(WasmI32.fromGrain(key))
  Memory.decRef(WasmI32.fromGrain(ident))
  int32_3
}

import foreign wasm get_ffi_result: (WasmI32, WasmI32) -> WasmI32 as witx_bindgen_getFfiResult from "env"
@disableGC
export let rec getFfiResult: (Int32, Int32) -> Int32 = (ptr, ident) => {
  let int32_0 = WasmI32.load(WasmI32.fromGrain(ptr), 8n)
  let int32_1 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  let ret = witx_bindgen_getFfiResult(int32_0, int32_1)
  let int32_2 = WasmI32.toGrain(DataStructures.newInt32(ret)): Int32
  Memory.decRef(WasmI32.fromGrain(getFfiResult))
  Memory.decRef(WasmI32.fromGrain(ptr))
  Memory.decRef(WasmI32.fromGrain(ident))
  int32_2
}

import foreign wasm return_abort: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> Void as witx_bindgen_returnAbort from "env"
@disableGC
export let rec returnAbort: (String, String, Int32, Int32, Int32) -> Void = (msg, file, lineNum, colNum, ident) => {
  let vec0 = msg
  let ptr0 = WasmI32.add(WasmI32.fromGrain(vec0), 8n)
  let len0 = WasmI32.load(WasmI32.fromGrain(vec0), 4n)
  let vec1 = file
  let ptr1 = WasmI32.add(WasmI32.fromGrain(vec1), 8n)
  let len1 = WasmI32.load(WasmI32.fromGrain(vec1), 4n)
  let int32_2 = WasmI32.load(WasmI32.fromGrain(lineNum), 8n)
  let int32_3 = WasmI32.load(WasmI32.fromGrain(colNum), 8n)
  let int32_4 = WasmI32.load(WasmI32.fromGrain(ident), 8n)
  witx_bindgen_returnAbort(ptr0, len0, ptr1, len1, int32_2, int32_3, int32_4)
  Memory.decRef(WasmI32.fromGrain(returnAbort))
  Memory.decRef(WasmI32.fromGrain(msg))
  Memory.decRef(WasmI32.fromGrain(file))
  Memory.decRef(WasmI32.fromGrain(lineNum))
  Memory.decRef(WasmI32.fromGrain(colNum))
  Memory.decRef(WasmI32.fromGrain(ident))
  void
}

